Python basics
\begin{enumerate}

\item Write an iterative function to add up all numbers from 1 to \emph{n} (inclusive) and return the sum.

\begin{answer}
\begin{lstlisting}
def foo_iter(n):
	total = 0
	for num in range(1,n+1):
		total += num
	return total
\end{lstlisting}
\end{answer}

\item Re-write the function above using recursion. Is your answer tail recursive?  Why?

\begin{answer}
The answer described below \emph{is} tail recursive because no additional information must be stored on the stack for each recursive call.

\begin{lstlisting}
def foo_rec(n, count=1, total=0):
	if count > n:
		return total
	total += count
	count += 1
	return foo_rec(n, count, total)
\end{lstlisting}
\end{answer}

\item How would you test the two functions you've written above? Explain test cases you would want to analyze, and write a function to run the tests.

\begin{answer}
\begin{itemize}
\item Extraneous cases: n=None, n is not an integer
\item Base cases: $n=-1$, $n=0$, $n=1$
\item General case: $n > 1$
\end{itemize}
The above functions are fruitful (have return values), so we can write test cases using the expected outputs. This can be done with hard-coded values or using a separate algorithm
to assert the validity of our function's return values.
\begin{lstlisting}
def test_foo_functions(n):
	# below suggests the formula for the sum 1+2+...+(n-1)+n
	expected = ( n * ( n + 1 ) ) // 2
	if foo_iter(n) != expected:
		print("iterative foo function produced an incorrect result!")
	if foo_rec(n) != expected:
		print("recursive foo function produced an incorrect result!")
\end{lstlisting}
\end{answer}

\end{enumerate}




